package ReadFq;
$ReadFq::VERSION = '0.01';

# A simple module to parse FASTA and FASTQ files, based on 
# Heng Li subroutine https://github.com/lh3/readfq
# (this readfq implementation differs from the original as it's also retaining the sequence comment)

use 5.014;
use Moo; 
use Data::Dumper;

use Carp qw(confess);

my @aux = undef;
my $fh = undef;
# A first test of OOP with Moo

has filename => (
    is => 'ro',  
    required => 1, 
    isa => sub {
        my $file = $_[0];
        if (-e "$file") {
                open $fh, '<', "$file" || confess("[ReadFq] Unable to *read* file <$file>");
        } else {
                confess("[ReadFq] Unable to find FASTA/FASTQ file <$file>");
        }
    }
);




 


sub get {
    my ($self, $o) = @_;
    my $seq = undef;
    my ($name, $comment, $sequence, $quality) = _Read_FastX_with_comments($fh, \@aux);
    $seq->{name} = $name;
    $seq->{comment} = $comment if (defined $comment);
    $seq->{seq} = $sequence;
    $seq->{qual} = $quality if (defined $quality);
    if (defined $name) {
        return $seq;
    } else {
        return;
    }
}


sub _Read_FastX_with_comments {
    my ( $fh, $aux ) = @_;
    @$aux = [ undef, 0 ] if ( !@$aux );
    return if ( $aux->[1] );
    if ( !defined( $aux->[0] ) ) {
        while ( readline($fh) )  {
            chomp;
            if ( substr( $_, 0, 1 ) eq '>' || substr( $_, 0, 1 ) eq '@' ) {
                $aux->[0] = $_;
                last;
            }
        }
        if ( !defined( $aux->[0] ) ) {
            $aux->[1] = 1;
            return;
        }
    }
    my ( $name, $comm ) =
        /^.(\S+)(?:\s+)(.+)/ ? ( $1, $2 )
      : /^.(\S+)/            ? ( $1, '' )
      :                        ( '', '' );
    my $seq = '';
    my $c;
    $aux->[0] = undef;
    while (<$fh>) {
        chomp;
        $c = substr( $_, 0, 1 );
        last if ( $c eq '>' || $c eq '@' || $c eq '+' );
        $seq .= $_;
    }
    $aux->[0] = $_;
    $aux->[1] = 1 if ( !defined( $aux->[0] ) );
    return ( $name, $comm, $seq ) if ( $c ne '+' );
    my $qual = '';
    while (<$fh>) {
        chomp;
        $qual .= $_;
        if ( length($qual) >= length($seq) ) {
            $aux->[0] = undef;
            return ( $name, $comm, $seq, $qual );
        }
    }
    $aux->[1] = 1;
    return ( $name, $seq );
}



 
1;